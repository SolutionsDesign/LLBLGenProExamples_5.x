//////////////////////////////////////////////////////////////
// <auto-generated>This code was generated by LLBLGen Pro 5.9.</auto-generated>
//////////////////////////////////////////////////////////////
// Code is generated on: Tuesday, 1 February 2022 16:31:17
// Code is generated using templates: SD.TemplateBindings.SharedTemplates
// Templates vendor: Solutions Design.
//////////////////////////////////////////////////////////////
using System;
using System.Linq;
using SD.LLBLGen.Pro.LinqSupportClasses;
using SD.LLBLGen.Pro.ORMSupportClasses;
using SD.LLBLGen.Pro.Examples.EntityClasses;
using SD.LLBLGen.Pro.Examples.FactoryClasses;

namespace SD.LLBLGen.Pro.Examples.Linq
{
	/// <summary>Meta-data class for the construction of Linq queries which are to be executed using LLBLGen Pro code.</summary>
	public partial class LinqMetaData : ILinqMetaData
	{
		/// <summary>CTor. Using this ctor will leave the transaction object to use empty. This is ok if you're not executing queries created with this
		/// meta data inside a transaction. If you're executing the queries created with this meta-data inside a transaction, either set the Transaction property
		/// on the IQueryable.Provider instance of the created LLBLGenProQuery object prior to execution or use the ctor which accepts a transaction object.</summary>
		public LinqMetaData() : this(null, null) { }
		
		/// <summary>CTor. If you're executing the queries created with this meta-data inside a transaction, pass a live ITransaction object to this ctor.</summary>
		/// <param name="transactionToUse">the transaction to use in queries created with this meta-data</param>
		/// <remarks> Be aware that the ITransaction object set via this property is kept alive by the LLBLGenProQuery objects created with this meta data
		/// till they go out of scope.</remarks>
		public LinqMetaData(ITransaction transactionToUse) : this(transactionToUse, null) { }
		
		/// <summary>CTor. If you're executing the queries created with this meta-data inside a transaction, pass a live ITransaction object to this ctor.</summary>
		/// <param name="transactionToUse">the transaction to use in queries created with this meta-data</param>
		/// <param name="customFunctionMappings">The custom function mappings to use. These take higher precedence than the ones in the DQE to use.</param>
		/// <remarks> Be aware that the ITransaction object set via this property is kept alive by the LLBLGenProQuery objects created with this meta data
		/// till they go out of scope.</remarks>
		public LinqMetaData(ITransaction transactionToUse, FunctionMappingStore customFunctionMappings)
		{
			this.TransactionToUse = transactionToUse;
			this.CustomFunctionMappings = customFunctionMappings;
		}
		
		/// <summary>returns the datasource to use in a Linq query for the entity type specified</summary>
		/// <param name="typeOfEntity">the type of the entity to get the datasource for</param>
		/// <returns>the requested datasource</returns>
		public IDataSource GetQueryableForEntity(int typeOfEntity)
		{
			switch((SD.LLBLGen.Pro.Examples.EntityType)typeOfEntity)
			{
				case SD.LLBLGen.Pro.Examples.EntityType.CategoryEntity:
					return this.Category;
				case SD.LLBLGen.Pro.Examples.EntityType.CustomerEntity:
					return this.Customer;
				case SD.LLBLGen.Pro.Examples.EntityType.CustomerCustomerDemoEntity:
					return this.CustomerCustomerDemo;
				case SD.LLBLGen.Pro.Examples.EntityType.CustomerDemographyEntity:
					return this.CustomerDemography;
				case SD.LLBLGen.Pro.Examples.EntityType.EmployeeEntity:
					return this.Employee;
				case SD.LLBLGen.Pro.Examples.EntityType.EmployeeTerritoryEntity:
					return this.EmployeeTerritory;
				case SD.LLBLGen.Pro.Examples.EntityType.OrderEntity:
					return this.Order;
				case SD.LLBLGen.Pro.Examples.EntityType.OrderDetailEntity:
					return this.OrderDetail;
				case SD.LLBLGen.Pro.Examples.EntityType.ProductEntity:
					return this.Product;
				case SD.LLBLGen.Pro.Examples.EntityType.RegionEntity:
					return this.Region;
				case SD.LLBLGen.Pro.Examples.EntityType.ShipperEntity:
					return this.Shipper;
				case SD.LLBLGen.Pro.Examples.EntityType.SupplierEntity:
					return this.Supplier;
				case SD.LLBLGen.Pro.Examples.EntityType.TerritoryEntity:
					return this.Territory;
				default:
					return null;
			}		}

		/// <summary>returns the datasource to use in a Linq query which wraps the specified SQL query and projects it to instances of type T</summary>
		/// <param name="sqlQuery">The SQL query to execute. Has to follow one of the parameter specification patterns for Plain SQL queries in the LLBLGen Pro Runtime Framework</param>
		/// <param name="parameterValues">The object which will provide the parameter values for the SQL query specified. Has to follow one of the parameter specification patterns for Plain SQL queries in the LLBLGen Pro Runtime Framework</param>
		/// <typeparam name="T">The type of the instances to project the rows into, returned by the SQL query specified</typeparam>
		/// <returns>the requested datasource</returns>
		[InMemoryCandidate]		
		public DataSource<T> FromSql<T>(string sqlQuery, object parameterValues)
			where T : class
		{
			return new DataSource<T>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse).SetWrappedPlainSQLQuerySpecification(sqlQuery, parameterValues);
		}

		/// <summary>returns the datasource to use in a Linq query for the entity type specified</summary>
		/// <typeparam name="TEntity">the type of the entity to get the datasource for</typeparam>
		/// <returns>the requested datasource</returns>
		public DataSource<TEntity> GetQueryableForEntity<TEntity>()
				where TEntity : class
		{
			return new DataSource<TEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse);
		}

		/// <summary>returns the datasource to use in a Linq query when targeting CategoryEntity instances in the database.</summary>
		public DataSource<CategoryEntity> Category
		{
			get { return new DataSource<CategoryEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting CustomerEntity instances in the database.</summary>
		public DataSource<CustomerEntity> Customer
		{
			get { return new DataSource<CustomerEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting CustomerCustomerDemoEntity instances in the database.</summary>
		public DataSource<CustomerCustomerDemoEntity> CustomerCustomerDemo
		{
			get { return new DataSource<CustomerCustomerDemoEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting CustomerDemographyEntity instances in the database.</summary>
		public DataSource<CustomerDemographyEntity> CustomerDemography
		{
			get { return new DataSource<CustomerDemographyEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting EmployeeEntity instances in the database.</summary>
		public DataSource<EmployeeEntity> Employee
		{
			get { return new DataSource<EmployeeEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting EmployeeTerritoryEntity instances in the database.</summary>
		public DataSource<EmployeeTerritoryEntity> EmployeeTerritory
		{
			get { return new DataSource<EmployeeTerritoryEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting OrderEntity instances in the database.</summary>
		public DataSource<OrderEntity> Order
		{
			get { return new DataSource<OrderEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting OrderDetailEntity instances in the database.</summary>
		public DataSource<OrderDetailEntity> OrderDetail
		{
			get { return new DataSource<OrderDetailEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting ProductEntity instances in the database.</summary>
		public DataSource<ProductEntity> Product
		{
			get { return new DataSource<ProductEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting RegionEntity instances in the database.</summary>
		public DataSource<RegionEntity> Region
		{
			get { return new DataSource<RegionEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting ShipperEntity instances in the database.</summary>
		public DataSource<ShipperEntity> Shipper
		{
			get { return new DataSource<ShipperEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting SupplierEntity instances in the database.</summary>
		public DataSource<SupplierEntity> Supplier
		{
			get { return new DataSource<SupplierEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}
		/// <summary>returns the datasource to use in a Linq query when targeting TerritoryEntity instances in the database.</summary>
		public DataSource<TerritoryEntity> Territory
		{
			get { return new DataSource<TerritoryEntity>(this.TransactionToUse, new ElementCreator(), this.CustomFunctionMappings, this.ContextToUse); }
		}


		/// <summary> Gets / sets the ITransaction to use for the queries created with this meta data object.</summary>
		/// <remarks> Be aware that the ITransaction object set via this property is kept alive by the LLBLGenProQuery objects created with this meta data
		/// till they go out of scope.</remarks>
		public ITransaction TransactionToUse { get; set; }

		/// <summary>Gets or sets the custom function mappings to use. These take higher precedence than the ones in the DQE to use</summary>
		public FunctionMappingStore CustomFunctionMappings { get; set; }
		
		/// <summary>Gets or sets the Context instance to use for entity fetches.</summary>
		public Context ContextToUse { get; set; }
	}
}